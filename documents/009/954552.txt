#include <cstdio>
#include <vector>
#include <algorithm>
#include <map>
#include <array>
#include <utility>
#include <climits>
using namespace std;

int rnd(int &a, int &b){
	static const int C = ~(1u << 31);
	static const int M = (1 << 16) - 1;
	a = 36969 * (a & M) + (a >> 16);
	b = 18000 * (b & M) + (b >> 16);
	return (C & ((a << 16) + b)) % 1000000;
}

int main(){
	int m, n, a, b, x, y, z;
	while(scanf("%d%d%d%d", &m, &n, &a, &b), m | n){
		vector<array<int,3>> v(n + m);
		for(int i = 0; i < m; ++i){
			scanf("%d%d%d", &x, &y, &z);
			v[i] = {{x, -y, -z}};
		}
		for(int i = m; i < n + m; ++i){
			x = rnd(a, b);
			y = rnd(a, b);
			z = rnd(a, b);
			v[i] = {{x, -y, -z}};
		}
		sort(v.begin(), v.end());
		int ans = 0;
		vector<map<int,int>> mps(m + n + 3);
		mps[0][100] = 100;
		for(size_t i = 1; i < mps.size(); ++i){
			mps[i][INT_MIN] = INT_MAX;
		}
		for(int i = 0; i < m + n; ++i){
			y = v[i][1];
			z = v[i][2];
			int left = 1, right = ans + 2;
			while(right - left > 1){
				int mid = (left + right) >> 1;
				const auto &mpm = mps[mid - 1];
				auto it = mpm.upper_bound(y);
				if(it != mpm.end() && it->second > z){
					left = mid;
				}
				else{
					right = mid;
				}
			}
			
			auto &mpl = mps[left];
			for(auto it = mpl.upper_bound(y); ; ){
				--it;
				if(it->second > z){
					break;
				}
				it = mpl.erase(it);
			}
			
			int &t = mpl.insert(make_pair(y, z)).first->second;
			t = max(t, z);
			ans = max(ans, left);
		}
		printf("%d\n", ans);
	}
}