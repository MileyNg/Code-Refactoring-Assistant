// -*- coding: utf-8 -*-
// Last-Updated : <2014/06/20 09:50:44 by samui>

#include <algorithm>
#include <iostream>
#include <cstdio>
#include <string>
#include <vector>
#include <climits>
#include <set>
#include <bitset>

#define MP(a, b) std::make_pair(a, b)
#define X first
#define Y second
#define rep(i,n) for(int (i) = 0; (i) < (int)(n); ++(i))
#define rer(i,l,n) for(int (i) = l; (i) <= (int)(n); ++(i))
#define reu(i,l,n) for(int (i) = l; (i) < (int)(n); ++(i))
template<typename T,typename U> inline void amin(T &x,U y){ if(y<x) x = y;}
template<typename T,typename U> inline void amax(T &x,U y){ if(x<y) x = y;}
template<typename TYPE,std::size_t SIZE>
std::size_t len(const TYPE (&array)[SIZE]){return SIZE;}

// データ構造
// 木
typedef struct node {
  int parent, lchild, rsibling;
  node(): parent(-1), lchild(-1), rsibling(-1) {}
} Node;

// 幾何ライブ
typedef long double LD;
const LD INF = 1e100;
const LD EPS = 1e-8;
const LD PI = acos(-1);
typedef std::pair<LD,LD> PLD;
typedef std::vector<std::pair<LD,LD>> VPLD2;

class Point{
public:
  LD x,y;
  Point(LD x = 0,LD y = 0): x(x),y(y){ };
  Point operator + (Point p) {return Point(x+p.x,y+p.y);};
  Point operator - (Point p) {return Point(x-p.x,y-p.y);};
  Point operator * (LD a) {return Point(x*a,y*a);};
  Point operator / (LD a) {return Point(x/a,y/a);};
  LD abs(){return std::sqrt(x*x+y*y);};
  Point unit(){LD u = abs();return Point(x,y)/u; };
};
typedef Point Vector2D;
LD dotProduct(const Vector2D a,const Vector2D b){
  return a.x*b.x+a.y*b.y;
}
LD crossProduct(const Vector2D a, const Vector2D b){return a.x*b.y-a.y*b.x;}
LD angle(Vector2D a,Vector2D b){
  return acos(dotProduct(a,b)/(a.abs()*b.abs()));
}
LD norm(Vector2D a){return a.x*a.x+a.y*a.y;}
Point projection(Point a1,Point a2,Point a3){
  // 点a3にたいする線分a1-a2上への射影をもとめる。
  LD d = dotProduct(a3-a1,a2-a1)/norm(a2-a1);
  return (a1+(a2-a1)*d);
}
Point reflection(Point a1,Point a2,Point a3){
  return (a3+(projection(a1,a2,a3)-a3)*2);
}
int ccw(Point a1,Point a2,Point a3){
  Vector2D a = a2-a1;
  Vector2D b = a3-a1;
  if(crossProduct(a,b) > EPS) return 1; // a1,a2,a3が反時計まわり
  if(crossProduct(a,b) < -EPS) return -1;//a1,a2,a3が時計まわり
  if(dotProduct(a,b) < -EPS) return +2; //a3--a1--a2 で直線
  if(norm(a)< norm(b)) return -2; // a1--a2--a3 の順で直線
  return 0; // a1--a3--a2の順番
}


int main(int argc, char *argv[])
{
  int N;
  std::cin>>N;
  Node G[N];
  rep(i,N){
    int id,k,c,cprev;
    std::cin>>id>>k;
    if(k){
      std::cin>>c;
      G[id].lchild = c;
      G[c].parent = id;
      cprev = c;
      rer(j,2,k){
	std::cin>>c;
	G[cprev].rsibling = c;
	G[c].parent = id;
	cprev = c;
      }
    }
  }
  rep(i,N){
    std::cout<<"node "<<i<<": parent = "<<G[i].parent<<", "<<std::flush;
    int j = i,t = 0;
    while(G[j].parent != -1){
      j = G[j].parent;
      t++;
    }
    std::cout<<"depth = "<<t<<", "<<std::flush;
    
    if(G[i].lchild == -1){
      if(t == 0){
	std::cout<<"root, []"<<std::endl;
      }else{
	std::cout<<"leaf, []"<<std::endl;
      }
    }else{
      if(t == 0){
	std::cout<<"root, ["<<std::flush;
      }else{
	std::cout<<"internal node, ["<<std::flush;
      }
      std::cout<<G[i].lchild<<std::flush;
      int j = G[i].lchild;
      while(G[j].rsibling!=-1){
	if(G[j].rsibling!=-1)
	  std::cout<<", "<<std::flush;
	j = G[j].rsibling;
	std::cout<<j<<std::flush;
      }
      std::cout<<"]"<<std::endl;

    }
  }
  
  return 0;
}